#lab2 实验报告
计22 黄杰 2012011272
----

练习0：填写已有实验

本实验依赖实验1。请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分。提示：可采用diff和patch工具进行半自动的合并（merge），也可用一些图形化的比较/merge工具来手动合并，比如meld，eclipse中的diff/merge工具，understand中的diff/merge工具等。
完成合并

练习1：实现 first-fit 连续物理内存分配算法

在实现first fit 内存分配算法的回收函数时，要考虑地址连续的空闲块之间的合并操作。提示:在建立空闲页块链表时，需要按照空闲页块起始地址来排序，形成一个有序的链表。可能会修改default_pmm.c中的default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数。请仔细查看和理解default_pmm.c中的注释。

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

你的first fit算法是否有进一步的改进空间
>我设计的first fit在allo操作时，分为两个步骤  
>第一个步骤寻找大小合适的空闲块，即第一个大小大于等于n的空闲块。  
>第二个步骤对空闲块分为两种情况进行处理，一种情况空闲块大小恰好等于所要分配的内存大小就将该块所在的page，都置为使用，且从空闲列表中去除。另一种情况空闲块大小大于要分配的内存大小，即还有剩余，就需要在以上操作的基础上设置剩余块的第一个page的propety值。  
>free过程分为三个步骤  
>第一：遍历空闲表找到地址位置恰好大于base位置的块  
>第二：将需要free的n个page插入到，这个恰好大于的位置之前  
>第三：合并连续的空闲块，主要是判断前后两个空闲的块是否正好紧密邻接。   
>优化：目前存在list中的是以page为单位存的，两个propety不为0的page之间可能存在很多为0的中间page。从一个空闲块，到下一个空闲块需要扫过每一个page，这是一种十分低效的行为。可以为每个page增加一个block_next的项，每个空闲块的头（即propety不为0的page有效),存储下一个propety不为0的page的地址。这样可以节约寻找空闲块、判断与前后空闲块合并的时间。但要付出一定的维护成本，当page的数量远多于block的数量的时候，这样的改进是有效的。

分析与参考答案的区别
>参考答案基本的策略与我的一致，在一些实现细节中略有不同。比如在allo操作中，参考答案在寻找到空闲块后直接进行处理然后再跳出循环，而我在确定需要修改的位置后跳出循环进行处理。在free操作中，需要进行相邻空闲块merge的时候，参考答案首先对下一块进行判断，再判断地址低的块。而我的实现中先对地址低的进行判断是否合并。


练习2：实现寻找虚拟地址对应的页表项（需要编程）

通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。其中的get_pte函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。本练习需要补全get_pte函数 in kern/mm/pmm.c，实现其功能。请仔细查看和理解get_pte函数中的注释。get_pte函数的调用关系图如下所示：
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
>设计实现过程：  
>需要实现函数get_pte完成从由虚地址到二级表项的内核虚地址的转换。
>首先根据虚地址用PDX得到页目录项的index，然后在pgdir中得到这个页目录项的内容。如果这个页目录项不存在的话。就调用alloc_page为其分配一项，新建page之后需要为这一page进行初始化，然后让这个页目录项指向这个新初始化的位置。  
>下一步根据得到的目录项，获取其中页表项的物理地址，然后用这个物理地址调用KADDR去获取了页表项的起始的内核虚地址，然后根据la中给出的页表项的index得到了对应的页表项的内核虚地址。

与参考答案的不同
>根据给出的注释完成了实验，步骤基本与参考答案类似，不同点在于将最后一步得到内核虚地址的表达式展开了，便于自己的编写与理解。

请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。

>页目录项 由   页表项的高位物理地址 +　pte_u + pte_w + pte_p三个标志位组成，这三个标志位分别表示是否用户态可以获取，时候可写，是否存在。   
>页表项   由   实际的物理地址的高位 + pte_u + pte_w + pte_p标志位的意义与也目录项一致。   

如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
>硬件的处理，与其他类型异常的处理情况类似，保存当前运行的地址，将对应寄存器压入栈中，然后软件跳转到异常处理代码部分。对于页访问异常就跳转到了页置换程序处。




练习3：释放某虚地址所在的页并取消对应二级页表项的映射（需要编程）

当释放一个包含某虚地址的物理内存页时，需要让对应此物理内存页的管理数据结构Page做相关的清除处理，使得此物理内存页成为空闲；另外还需把表示虚地址与物理地址对应关系的二级页表项清除。请仔细查看和理解page_remove_pte函数中的注释。为此，需要补全在 kern/mm/pmm.c中的page_remove_pte函数。page_remove_pte函数的调用关系图如下所示：
图2 page_remove_pte函数的调用关系图
请在实验报告中简要说明你的设计实现过程。请回答如下问题：

>设计实现过程
>函数实现了释放虚地址所在页并取消二级页表映射的功能。对于给定的页表项首先判断这个页表项是否存在，如果不存在也就不需要操作。  
>如果存在得到该虚地址所在的page利用page_ref_dec函数将页引用次数减1，如果返回的页引用的结果为0，即没有项引用了该页，就可以将该页从内存中释放。  
>下一步取消二级页表的映射，调用tlb_invalidate函数刷新一下tlb。

与参考答案的不同
>根据给出的注释完成了实验，步骤基本与参考答案类似。


数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？
>有对应关系，页表项中的每一项对应一个page，指向pages第n项的页表项的内容的前20位即为n。即页表项的前20位就是page的index。

如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题
>需要修改kernbase的值，将虚拟地址的开始地址从0xc000000修改为0x0，即让虚拟地址的起始于物理地址相同，达到使虚拟地址与物理地址相同的设置。


列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解
>本实验中重要的知识点：连续内存分配算法，在本次实验中只要求实现了first-fit的连续内存分配算法，应当同时了解其他在原理课中讲述的分配算法，并明白不同分配算法之间的联系与不同点。操作系统页机制的实现，这一块包含了很多知识点，包括实验中需要实现的从虚拟地址对应的页表项，和释放虚地址所在的页。这些对应原理课中所讲述的二级页表的结构和对应关系，以及页表项、页目录项的构成，和如何利用这些项上的信息完成从虚拟地址到物理地址的转换。

列出你认为OS原理中很重要，但在实验中没有对应上的知识点
>在原理课中还设计到了关于快表和反置页表的知识点，在实验中并未涉及到。除此之外对段页式内存管理的内容也有部分没有涉及到。



